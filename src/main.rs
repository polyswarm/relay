extern crate base64;
extern crate clap;
extern crate config;
extern crate consul;
extern crate ctrlc;
extern crate env_logger;
extern crate tokio_core;
extern crate web3;

extern crate failure;
#[macro_use]
extern crate failure_derive;
#[macro_use]
extern crate log;
extern crate jsonrpc_core as rpc;
extern crate parking_lot;
#[macro_use]
extern crate serde_derive;
extern crate serde_json;

use clap::{App, Arg};

pub mod consul_configs;
pub mod contracts;
pub mod errors;
pub mod relay;
pub mod settings;

#[cfg(test)]
mod mock;
use std::io::Write;

use failure::{Error, SyncFailure};
use relay::{Network, Relay};
use settings::{LogFmt, Settings};

use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::time::Duration;

use log::LevelFilter;

fn main() -> Result<(), Error> {
    // Set up ctrl-c handler
    let running = Arc::new(AtomicBool::new(true));

    let running_ = running.clone();
    ctrlc::set_handler(move || {
        info!("ctrl-c caught, exiting...");
        running_.store(false, Ordering::SeqCst);
    })?;

    let mut builder = env_logger::Builder::new();

    // Parse options
    let matches = App::new("Polyswarm Relay")
        .version("0.1.0")
        .author("PolySwarm Developers <info@polyswarm.io>")
        .about("Relays ERC20 tokens between two different networks.")
        .arg(
            Arg::with_name("config")
                .value_name("TOML config file")
                .help("Configures the two networks we will relay between")
                .required(true)
                .takes_value(true),
        ).arg(
            Arg::with_name("logging")
                .value_name("Logging output format")
                .help("Specify the logging output format")
                .takes_value(true),
        ).get_matches();

    let settings = Settings::new(matches.value_of("config"))?;

    // borrow rather than copying for the benefit of the following closure
    let log_format = settings.logging.format;

    // This is a mini-formatter pipe for messages generated by the failure crate and logging macros.
    builder
        .format(move |buf, record| match log_format {
            LogFmt::Raw => write!(buf, "msg= {}", record.args()),
            LogFmt::JSON => write!(buf, "{{ unit: \"relay-rust\", message: {} }}", record.args()),
        }).filter(None, LevelFilter::Info)
        .init();

    // Set up our two websocket connections on the same event loop
    let mut eloop = tokio_core::reactor::Core::new()?;
    let handle = eloop.handle();
    let home_ws = web3::transports::WebSocket::with_event_loop(&settings.relay.homechain.ws_uri, &handle)
        .map_err(SyncFailure::new)?;
    let side_ws = web3::transports::WebSocket::with_event_loop(&settings.relay.sidechain.ws_uri, &handle)
        .map_err(SyncFailure::new)?;

    let relay = Relay::new(
        Network::homechain(
            home_ws.clone(),
            &settings.relay.account,
            &*consul_configs::wait_or_get("homechain", "nectar_token_address"),
            &*consul_configs::wait_or_get("homechain", "erc20_relay_address"),
            settings.relay.confirmations,
        )?,
        Network::sidechain(
            side_ws.clone(),
            &settings.relay.account,
            &*consul_configs::wait_or_get("sidechain", "nectar_token_address"),
            &*consul_configs::wait_or_get("sidechain", "erc20_relay_address"),
            settings.relay.confirmations,
            settings.relay.anchor_frequency,
        )?,
    );

    // Unlock accounts now
    eloop.run(relay.unlock(&settings.relay.password))?;

    // Run the relay
    handle.spawn(relay.run(&handle));
    while running.load(Ordering::SeqCst) {
        eloop.turn(Some(Duration::from_secs(1)));
    }

    Ok(())
}
